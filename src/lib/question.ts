import type { MessagePlatform } from '@prisma/client';
import pLimit, { type LimitFunction } from 'p-limit';

/**
 * All question variants supported by the game. For more information about individual variants, see
 * the variant questions generators in `$lib/server`. The `proposal` variant is only handled in the
 * client because it involves a fixed question.
 */
export type QuestionVariant =
	| 'continue'
	| 'duration'
	| 'platform'
	| 'proposal'
	| 'react'
	| 'when'
	| 'who';

/**
 * Represents a message in a conversation to be used in a question This is slightly different from
 * the representation in the database to allow simplified rendering.
 */
export type QuestionMessage = {
	content: string;
	date: Date;
	isMedia: boolean;
	participant: string;
	platform: MessagePlatform;
	reaction: string;
};

/**
 * Represents a question that is asked to the player. This is generated by the server and rendered
 * by the client. All question variants share the same format, but may be rendered differently.
 */
export type Question = {
	answer: string;
	choices: Array<string>;
	messages: Array<QuestionMessage>;
	recipient: string;
	variant: QuestionVariant;
};

/**
 * Configuration for the question bank.
 */
export type QuestionBankConfig = {
	/**
	 *  The concurrency limit to apply when fetching questions.
	 */
	concurrency?: number;

	/**
	 * The initial seed to use. The same initial seed guarantees the same sequence of questions.
	 */
	initialSeed?: string;

	/**
	 * The maximum number of questions to cache at any given time.
	 */
	maxCacheSize?: number;
};

/**
 * The question bank caches questions from the server and handles initial seed manipulation. This
 * ensures that the client can have the perception that there is no loading time between questions.
 */
export class QuestionBank {
	/**
	 * The API URL to use when communicating with the server.
	 */
	private static _API_URL = '/question';

	/**
	 * Configuration for the question bank.
	 */
	private readonly _config: Required<QuestionBankConfig>;
	/**
	 * The concurrency limit function to apply when fetching questions.
	 */
	private readonly _pLimit: LimitFunction;

	/**
	 * The cache of questions.
	 */
	private _cache: Array<Promise<Question>> = [];
	/**
	 * The current question count. This is combined with the seed to generated different questions.
	 */
	private _count: number = 0;

	/**
	 * Creates a new question bank.
	 */
	constructor(config?: QuestionBankConfig) {
		this._config = {
			concurrency: config?.concurrency ?? 1,
			initialSeed: config?.initialSeed ?? '',
			maxCacheSize: config?.maxCacheSize ?? 10
		};
		this._pLimit = pLimit(this._config.concurrency);
		this._poll();
	}

	/**
	 * Returns a question from the question bank. Logs any errors and retries until a question was
	 * successfully returned.
	 */
	async getQuestion(): Promise<Question> {
		while (true) {
			this._poll();
			try {
				const question = await this._cache.shift();
				if (question === undefined) {
					throw new Error('Unexpected empty cache after poll');
				}
				return question;
			} catch (error) {
				console.log(error);
			}
		}
	}

	/**
	 * Returns the next seed to pass to the server.
	 */
	private _nextSeed(): string {
		return `${this._config.initialSeed}-${this._count++}`;
	}

	/**
	 * Polls for questions and adds them to the cache.
	 */
	private _poll(): void {
		while (this._cache.length < this._config.maxCacheSize) {
			const params = new URLSearchParams({ seed: this._nextSeed() });
			this._cache.push(
				this._pLimit(async () => {
					const result = await fetch(`${QuestionBank._API_URL}?${params}`);
					return this._questionFromString(await result.text());
				})
			);
		}
	}

	/**
	 * Returns a question from a JSON string. Assumes that the input is valid.
	 */
	private _questionFromString(jsonString: string): Question {
		const question = JSON.parse(jsonString);
		question.messages.forEach((message: any) => {
			message.date = new Date(message.date);
		});
		return question as Question;
	}
}

/**
 * Represents mask options for attributes of a message.
 */
export type QuestionMessageMask = {
	maskContent: boolean;
	maskMetadata: boolean;
	maskReaction: boolean;
};

/**
 * Represents mask options for a question.
 */
export type QuestionMask = { maskRecipient: boolean; messageMasks: Array<QuestionMessageMask> };

/**
 * Returns the mask options for the corresponding question. This is exclusively handled by the
 * client because it is deterministically generated for each question.
 */
export function generateQuestionMask(question: Question): QuestionMask {
	const mask = {
		maskRecipient: false,
		messageMasks: question.messages.map(() => ({
			maskContent: false,
			maskMetadata: false,
			maskReaction: false
		}))
	};

	switch (question.variant) {
		case 'continue':
			mask.messageMasks[mask.messageMasks.length - 1].maskContent = true;
			break;
		case 'duration':
			mask.messageMasks[mask.messageMasks.length - 1].maskMetadata = true;
			break;
		case 'platform':
			mask.messageMasks.forEach((messageMask, i) => {
				messageMask.maskMetadata = true;
				if (i !== mask.messageMasks.length - 1) {
					messageMask.maskContent = true;
				}
			});
			break;
		case 'proposal':
			mask.messageMasks[mask.messageMasks.length - 1].maskContent = true;
			break;
		case 'react':
			mask.messageMasks[mask.messageMasks.length - 1].maskReaction = true;
			break;
		case 'when':
			mask.messageMasks.forEach((messageMask) => {
				messageMask.maskMetadata = true;
			});
			break;
		case 'who':
			mask.maskRecipient = true;
			mask.messageMasks.forEach((messageMask, i) => {
				if (i !== mask.messageMasks.length - 1) {
					messageMask.maskContent = true;
				}
			});
			break;
	}

	return mask;
}
