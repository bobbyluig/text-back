import type { MessagePlatform } from '@prisma/client';
import pLimit, { type LimitFunction } from 'p-limit';

/**
 * All question variants supported by the game. For more information about individual variants, see
 * the variant questions generators in `$lib/server`. Some variants may only be used by the client.
 */
export type QuestionVariant =
	| 'continue'
	| 'duration'
	| 'none'
	| 'platform'
	| 'proposal'
	| 'react'
	| 'when'
	| 'who';

/**
 * Represents a message in a conversation to be used in a question This is slightly different from
 * the representation in the database to allow simplified rendering.
 */
export type QuestionMessage = {
	content: string;
	date: Date;
	isMedia: boolean;
	participant: string;
	platform: MessagePlatform;
	reaction: string;
};

/**
 * Represents a question that is asked to the player. This is generated by the server.
 */
export type Question = {
	answer: string;
	choices: Array<string>;
	messages: Array<QuestionMessage>;
	recipient: string;
	variant: QuestionVariant;
};

/**
 * Configuration for the question bank.
 */
export type QuestionBankConfig = {
	/**
	 *  The concurrency limit to apply when fetching questions.
	 */
	concurrency?: number;

	/**
	 * The initial seed to use. The same initial seed guarantees the same sequence of questions.
	 */
	initialSeed?: string;

	/**
	 * The maximum number of questions to cache at any given time.
	 */
	maxCacheSize?: number;
};

/**
 * The question bank caches questions from the server and handles initial seed manipulation. This
 * ensures that the client can have the perception that there is no loading time between questions.
 */
export class QuestionBank {
	/**
	 * The API URL to use when communicating with the server.
	 */
	private static _API_URL = '/question';

	/**
	 * Configuration for the question bank.
	 */
	private readonly _config: Required<QuestionBankConfig>;
	/**
	 * The concurrency limit function to apply when fetching questions.
	 */
	private readonly _pLimit: LimitFunction;

	/**
	 * The cache of questions.
	 */
	private _cache: Array<Promise<Question>> = [];
	/**
	 * The current question count. This is combined with the seed to generated different questions.
	 */
	private _count: number = 0;

	/**
	 * Creates a new question bank.
	 */
	constructor(config?: QuestionBankConfig) {
		this._config = {
			concurrency: config?.concurrency ?? 1,
			initialSeed: config?.initialSeed ?? '',
			maxCacheSize: config?.maxCacheSize ?? 10
		};
		this._pLimit = pLimit(this._config.concurrency);
		this._poll();
	}

	/**
	 * Returns a question from the question bank. Logs any errors and retries until a question was
	 * successfully returned.
	 */
	async getQuestion(): Promise<Question> {
		while (true) {
			this._poll();
			try {
				const question = await this._cache.shift();
				if (question === undefined) {
					throw new Error('Unexpected empty cache after poll');
				}
				return question;
			} catch (error) {
				console.log(error);
			}
		}
	}

	/**
	 * Returns the next seed to pass to the server.
	 */
	private _nextSeed(): string {
		return `${this._config.initialSeed}-${this._count++}`;
	}

	/**
	 * Polls for questions and adds them to the cache.
	 */
	private _poll(): void {
		while (this._cache.length < this._config.maxCacheSize) {
			const params = new URLSearchParams({ seed: this._nextSeed() });
			this._cache.push(
				this._pLimit(async () => {
					const result = await fetch(`${QuestionBank._API_URL}?${params}`);
					return this._questionFromString(await result.text());
				})
			);
		}
	}

	/**
	 * Returns a question from a JSON string. Assumes that the input is valid.
	 */
	private _questionFromString(jsonString: string): Question {
		const question = JSON.parse(jsonString);
		question.messages.forEach((message: any) => {
			message.date = new Date(message.date);
		});
		return question as Question;
	}
}

/**
 * Represents mask options for attributes of a message.
 */
export type QuestionMessageMask = {
	content: boolean;
	date: boolean;
	platform: boolean;
	reaction: boolean;
};

/**
 * Represents mask options for attributes of a question.
 */
export type QuestionMask = { recipient: boolean; messages: Array<QuestionMessageMask> };

/**
 * Returns the mask options for the corresponding question. This is exclusively handled by the
 * client because it is deterministically generated for each question.
 */
export function getQuestionMask(question: Question): QuestionMask {
	const mask = {
		recipient: false,
		messages: question.messages.map(() => ({
			content: false,
			date: false,
			platform: false,
			reaction: false
		}))
	};

	switch (question.variant) {
		case 'continue':
			mask.messages[mask.messages.length - 1].content = true;
			return mask;
		case 'duration':
			mask.messages[mask.messages.length - 1].date = true;
			return mask;
		case 'none':
			return mask;
		case 'platform':
			mask.messages.forEach((message, i) => {
				message.platform = true;
				if (i !== mask.messages.length - 1) {
					message.content = true;
				}
			});
			return mask;
		case 'proposal':
			mask.messages[mask.messages.length - 1].content = true;
			return mask;
		case 'react':
			mask.messages[mask.messages.length - 1].reaction = true;
			return mask;
		case 'when':
			mask.messages.forEach((message) => {
				message.date = true;
			});
			return mask;
		case 'who':
			mask.recipient = true;
			mask.messages.forEach((message, i) => {
				if (i !== mask.messages.length - 1) {
					message.content = true;
				}
			});
			return mask;
	}
}

/**
 * Returns the description for a question to be shown in the client.
 */
export function getQuestionDescription(question: Question): string {
	const recipient = question.recipient;
	const sender = question.messages[question.messages.length - 1].participant;

	switch (question.variant) {
		case 'continue':
			return `What was the hidden message to ${recipient}?`;
		case 'duration':
			return `How long did it take for ${sender} to reply?`;
		case 'none':
			return '';
		case 'platform':
			return `What platform was the last message sent from?`;
		case 'proposal':
			return `What was the hidden message to ${recipient}?`;
		case 'react':
			return `What was the reaction on ${sender}'s message?`;
		case 'when':
			return `What day was the last message sent on?`;
		case 'who':
			return `Who sent the last message?`;
	}
}
